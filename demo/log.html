<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Ork Log</title>
<style type="text/css">
body, html { background: #EEEEEE; color: #000000; font-family: sans-serif; }
.DATE { background: #DDDDDD; color: #333333; vertical-align: top; }
.DEBUG { color: #888888; }
.WARNING { color: #CC9900; }
.ERROR { color: #CC0000; }
</style>
</head>
<body>
<table cellspacing="0" cellpadding="2">
<tr><td class="DATE">10:55:46</td>
<td class="INFO">[RESOURCE] Loading resource <b>window</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>archives/earth/earth.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>archives/earth/earth.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[UI] Status: Using GLEW 1.13.0
</td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>defaultScheduler</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>scene</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>cameraMethod</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>methods/cameraMethod.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>methods/cameraMethod.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>globalsShaderFS</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/globalsShaderFS.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/globalsShaderFS.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/globalsShader.glsl</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/globalsShader.glhl</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/globalsShader.glsl</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/globalsShader.glhl</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[COMPILER] Compiled module <b>globalsShaderFS</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>sunMethod</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>methods/sunMethod.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>methods/sunMethod.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>earth1</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundElevations1</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundElevations</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundResiduals1</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundResiduals</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>upsampleShader;</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>upsampleShader</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/elevation/upsampleShader.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/elevation/upsampleShader.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/elevation/upsampleShader.glsl</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[COMPILER] Compiled module <b>upsampleShader</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>renderbuffer-29-RGBA32F</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>renderbuffer-29-R32F</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[TILESAMPLERZ] Storage textures: 1</td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[TILESAMPLERZ] inputs[0]</td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundNormals1</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundNormals</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>normalShader;</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>normalShader</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/elevation/normalShader.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/elevation/normalShader.xml</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/elevation/normalShader.glsl</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[COMPILER] Compiled module <b>normalShader</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>renderbuffer-25-RGBA8</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundOrthoGpu1</b></td></tr>
<tr><td class="DATE">10:55:47</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundOrthoGpu</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundOrthoCpu1</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loading resource <b>groundOrthoCpu</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loading resource <b>renderbuffer-196-COMPRESSED_RGBA_S3TC_DXT5_EXT</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loading resource <b>renderbuffer-196-RGBA8</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loading resource <b>grid25.mesh</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>meshes/grid25.mesh</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loading resource <b>updateTerrainMethod</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>methods/updateTerrainMethod.xml</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>methods/updateTerrainMethod.xml</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loading resource <b>drawTerrainMethod</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>methods/drawTerrainMethod.xml</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>methods/drawTerrainMethod.xml</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loading resource <b>earthShader-VN</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/earth/earthShader-VN.xml</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/earth/earthShader-VN.xml</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/earth/earthShader.glsl</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/globalsShader.glhl</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/textureTile.glsl</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/atmo/atmosphereShader.glhl</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/ocean/oceanBrdf.glhl</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/trees/treeBrdf.glhl</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="INFO">[RESOURCE] Loaded file <b>shaders/clouds/clouds.glhl</b></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="ERROR">[COMPILER] <pre>
1: #version 330
2: #define _VERTEX_
3: #define VERTEX_NORMALS
4: /*
5:  * Proland: a procedural landscape rendering library.
6:  * Copyright (c) 2008-2011 INRIA
7:  *
8:  * This program is free software: you can redistribute it and/or modify
9:  * it under the terms of the GNU General Public License as published by
10:  * the Free Software Foundation, either version 3 of the License, or
11:  * (at your option) any later version.
12:  *
13:  * This program is distributed in the hope that it will be useful,
14:  * but WITHOUT ANY WARRANTY; without even the implied warranty of
15:  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:  * GNU General Public License for more details.
17:  *
18:  * You should have received a copy of the GNU General Public License
19:  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
20:  */
21: 
22: /*
23:  * Proland is distributed under a dual-license scheme.
24:  * You can obtain a specific license from Inria: proland-licensing@inria.fr.
25:  */
26: 
27: /*
28:  * Authors: Eric Bruneton, Antoine Begault, Guillaume Piolat.
29:  */
30: 
31: /*
32:  * Proland: a procedural landscape rendering library.
33:  * Copyright (c) 2008-2011 INRIA
34:  *
35:  * This program is free software: you can redistribute it and/or modify
36:  * it under the terms of the GNU General Public License as published by
37:  * the Free Software Foundation, either version 3 of the License, or
38:  * (at your option) any later version.
39:  *
40:  * This program is distributed in the hope that it will be useful,
41:  * but WITHOUT ANY WARRANTY; without even the implied warranty of
42:  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
43:  * GNU General Public License for more details.
44:  *
45:  * You should have received a copy of the GNU General Public License
46:  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
47:  */
48: 
49: /*
50:  * Proland is distributed under a dual-license scheme.
51:  * You can obtain a specific license from Inria: proland-licensing@inria.fr.
52:  */
53: 
54: /*
55:  * Authors: Eric Bruneton, Antoine Begault, Guillaume Piolat.
56:  */
57: 
58: vec3 getWorldCameraPos();
59: 
60: vec3 getWorldSunDir();
61: 
62: // TONE MAPPING
63: 
64: float getHdrExposure();
65: 
66: vec3 hdr(vec3 L);
67: 
68: // EDITION
69: 
70: vec4 getPencil();
71: 
72: vec4 getPencilColor();
73: 
74: // OCEANS
75: 
76: vec3 getSeaColor();
77: 
78: float getSeaRoughness();
79: 
80: // TREES
81: 
82: float getTreeHeight(int species);
83: 
84: float getTreeBase(int species);
85: 
86: float getTreeDensity();
87: 
88: float getMaxTreeDistance();
89: 
90: float getShadowLimit(int i);
91: 
92: mat4 getTangentFrameToShadow(int i);
93: 
94: /*
95:  * Proland: a procedural landscape rendering library.
96:  * Copyright (c) 2008-2011 INRIA
97:  *
98:  * This program is free software: you can redistribute it and/or modify
99:  * it under the terms of the GNU General Public License as published by
100:  * the Free Software Foundation, either version 3 of the License, or
101:  * (at your option) any later version.
102:  *
103:  * This program is distributed in the hope that it will be useful,
104:  * but WITHOUT ANY WARRANTY; without even the implied warranty of
105:  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
106:  * GNU General Public License for more details.
107:  *
108:  * You should have received a copy of the GNU General Public License
109:  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
110:  */
111: 
112: /*
113:  * Proland is distributed under a dual-license scheme.
114:  * You can obtain a specific license from Inria: proland-licensing@inria.fr.
115:  */
116: 
117: /*
118:  * Authors: Eric Bruneton, Antoine Begault, Guillaume Piolat.
119:  */
120: 
121: // debug option to highlight or hide quadtree quads
122: #define QUADTREE_OFF
123: 
124: #ifdef GL_EXT_texture_array
125: #extension GL_EXT_texture_array : enable
126: #endif
127: 
128: struct samplerTile {
129:     sampler2DArray tilePool; // tile cache
130: 
131:     // currently selected tile
132:     vec3 tileCoords; // coords of currently selected tile in tile cache (u,v,layer; u,v in [0,1]^2)
133:     vec3 tileSize; // size of currently selected tile in tile cache (du,dv,d; du,dv in [0,1]^2, d in pixels)
134: 
135:     // tile map info (indirection structure to get tile coords in tile cache from absolute position)
136:     sampler2D tileMap; // associates tile coords in tile cache (in pixels) to tile id (level, tx, ty) (tx, ty relative to tx,ty of tile under camera)
137:     vec4 quadInfo; // rootTileSize, splitDistance, k=ceil(splitDistance), 4*k+2
138:     vec4 poolInfo; // tile size in pixels including borders, border in pixels, tilePool 1/w,1/h
139:     vec4 camera[6]; // camera xyz, max quadtree level
140: };
141: 
142: // returns content of currently selected tile, at uv coordinates (in [0,1]^2; relatively to this tile)
143: vec4 textureTile(samplerTile tex, vec2 uv) {
144:     vec3 uvl = tex.tileCoords + vec3(uv * tex.tileSize.xy, 0.0);
145:     return texture(tex.tilePool, uvl);
146: }
147: 
148: 
149: #define SPHERE_PROJECTION
150: 
151: #if !defined(VERTEX_NORMALS) && !defined(FRAGMENT_NORMALS)
152: #define VERTEX_NORMALS
153: #endif
154: 
155: uniform samplerTile elevationSampler;
156: uniform samplerTile vertexNormalSampler;
157: uniform samplerTile fragmentNormalSampler;
158: uniform samplerTile orthoSampler;
159: uniform samplerTile ambientApertureSampler;
160: uniform samplerTile lccSampler;
161: 
162: uniform struct {
163:     vec4 offset;
164:     vec4 camera;
165:     vec2 blending;
166:     mat4 localToScreen;
167:     float radius;
168:     mat3 localToWorld;
169:     mat4 screenQuadCorners;
170:     mat4 screenQuadVerticals;
171:     vec4 screenQuadCornerNorms;
172:     mat3 tangentFrameToWorld;
173:     mat3 tileToTangent;
174: } deformation;
175: 
176: #ifdef _VERTEX_
177: 
178: layout(location=0) in vec3 vertex;
179: #ifdef FLIP
180: float h;
181: vec3 p;
182: vec3 q;
183: vec3 n;
184: vec2 uv;
185: out float hIn;
186: out float h0In;
187: out vec3 pIn;
188: out vec3 qIn;
189: out vec3 nIn;
190: out vec2 uvIn;
191: #else
192: out float h;
193: out vec3 p;
194: out vec3 q;
195: out vec3 n;
196: out vec2 uv;
197: #endif
198: 
199: void main() {
200:     vec4 zfc = textureTile(elevationSampler, vertex.xy);
201:     vec4 nfc = textureTile(vertexNormalSampler, vertex.xy) * 2.0 - vec4(1.0);
202: 
203:     vec2 v = abs(deformation.camera.xy - vertex.xy);
204:     float d = max(max(v.x, v.y), deformation.camera.z);
205:     float blend = clamp((d - deformation.blending.x) / deformation.blending.y, 0.0, 1.0);
206: 
207:     float R = deformation.radius;
208:     mat4 C = deformation.screenQuadCorners;
209:     mat4 N = deformation.screenQuadVerticals;
210:     vec4 L = deformation.screenQuadCornerNorms;
211:     vec3 P = vec3(vertex.xy * deformation.offset.z + deformation.offset.xy, R);
212: 
213:     vec4 uvUV = vec4(vertex.xy, vec2(1.0) - vertex.xy);
214:     vec4 alpha = uvUV.zxzx * uvUV.wwyy;
215:     vec4 alphaPrime = alpha * L / dot(alpha, L);
216: 
217:     h = zfc.z * (1.0 - blend) + zfc.y * blend;
218:     float k = min(length(P) / dot(alpha, L) * 1.0000003, 1.0);
219:     float hPrime = (h + R * (1.0 - k)) / k;
220: 
221: #ifdef CUBE_PROJECTION
222:     gl_Position = deformation.localToScreen * vec4(P + vec3(0.0, 0.0, h), 1.0);
223: #else
224:     gl_Position = (C + hPrime * N) * alphaPrime;
225: #endif
226:     p = (deformation.radius + h) * normalize(deformation.localToWorld * P);
227:     q = vec3((deformation.tileToTangent * vec3(vertex.xy, 1.0)).xy, h);
228: 
229: #ifdef VERTEX_NORMALS
230:     vec3 nf = vec3(nfc.xy, sqrt(1.0 - dot(nfc.xy, nfc.xy)));
231:     vec3 nc = vec3(nfc.zw, sqrt(1.0 - dot(nfc.zw, nfc.zw)));
232:     n = deformation.tangentFrameToWorld * (nf * (1.0 - blend) + nc * blend);
233: #endif
234: 
235:     uv = vertex.xy;
236: #ifdef FLIP
237:     hIn = h;
238:     h0In = zfc.z;
239:     pIn = p;
240:     qIn = q;
241:     nIn = n;
242:     uvIn = uv;
243: #endif
244: }
245: 
246: #endif
247: 
248: #ifdef _FRAGMENT_
249: 
250: /*
251:  * Proland: a procedural landscape rendering library.
252:  * Copyright (c) 2008-2011 INRIA
253:  *
254:  * This program is free software: you can redistribute it and/or modify
255:  * it under the terms of the GNU General Public License as published by
256:  * the Free Software Foundation, either version 3 of the License, or
257:  * (at your option) any later version.
258:  *
259:  * This program is distributed in the hope that it will be useful,
260:  * but WITHOUT ANY WARRANTY; without even the implied warranty of
261:  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
262:  * GNU General Public License for more details.
263:  *
264:  * You should have received a copy of the GNU General Public License
265:  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
266:  */
267: 
268: /*
269:  * Proland is distributed under a dual-license scheme.
270:  * You can obtain a specific license from Inria: proland-licensing@inria.fr.
271:  */
272: 
273: /*
274:  * Authors: Eric Bruneton, Antoine Begault, Guillaume Piolat.
275:  */
276: 
277: #define SUN_INTENSITY 100.0
278: 
279: #define PLANET_RADIUS 6360000.0
280: 
281: vec3 outerSunRadiance(vec3 viewdir);
282: 
283: vec3 sunRadiance(float r, float muS);
284: 
285: vec3 skyIrradiance(float r, float muS);
286: 
287: vec3 skyRadiance(vec3 camera, vec3 viewdir, vec3 sundir, out vec3 extinction, float shaftWidth);
288: 
289: void sunRadianceAndSkyIrradiance(vec3 worldP, vec3 worldN, vec3 worldS, out vec3 sunL, out vec3 skyE);
290: 
291: void sunRadianceAndSkyIrradiance(vec3 worldP, vec3 worldN, vec3 worldS, float pixelScale, vec4 ambientAperture, out vec3 sunL, out vec3 skyE);
292: 
293: vec3 inScattering(vec3 camera, vec3 point, vec3 sundir, out vec3 extinction, float shaftWidth);
294: 
295: /*
296:  * Proland: a procedural landscape rendering library.
297:  * Copyright (c) 2008-2011 INRIA
298:  *
299:  * This program is free software: you can redistribute it and/or modify
300:  * it under the terms of the GNU General Public License as published by
301:  * the Free Software Foundation, either version 3 of the License, or
302:  * (at your option) any later version.
303:  *
304:  * This program is distributed in the hope that it will be useful,
305:  * but WITHOUT ANY WARRANTY; without even the implied warranty of
306:  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
307:  * GNU General Public License for more details.
308:  *
309:  * You should have received a copy of the GNU General Public License
310:  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
311:  */
312: 
313: /*
314:  * Proland is distributed under a dual-license scheme.
315:  * You can obtain a specific license from Inria: proland-licensing@inria.fr.
316:  */
317: 
318: /*
319:  * Authors: Eric Bruneton, Antoine Begault, Guillaume Piolat.
320:  */
321: 
322: vec3 oceanRadiance(vec3 V, vec3 N, vec3 L, float seaRoughness, vec3 sunL, vec3 skyE);
323: 
324: /*
325:  * Proland: a procedural landscape rendering library.
326:  * Copyright (c) 2008-2011 INRIA
327:  *
328:  * This program is free software: you can redistribute it and/or modify
329:  * it under the terms of the GNU General Public License as published by
330:  * the Free Software Foundation, either version 3 of the License, or
331:  * (at your option) any later version.
332:  *
333:  * This program is distributed in the hope that it will be useful,
334:  * but WITHOUT ANY WARRANTY; without even the implied warranty of
335:  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
336:  * GNU General Public License for more details.
337:  *
338:  * You should have received a copy of the GNU General Public License
339:  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
340:  */
341: 
342: /*
343:  * Proland is distributed under a dual-license scheme.
344:  * You can obtain a specific license from Inria: proland-licensing@inria.fr.
345:  */
346: 
347: /*
348:  * Authors: Eric Bruneton, Antoine Begault, Guillaume Piolat.
349:  */
350: 
351: const float MIN_RADIUS = 0.848;
352: const float MAX_RADIUS = 1.21;
353: 
354: vec3 treeBrdf(vec3 q, float d, vec4 lc, vec3 v, vec3 fn, vec3 WSD, vec3 V, vec3 reflectance, vec3 sunL, vec3 skyE);
355: 
356: /*
357:  * Proland: a procedural landscape rendering library.
358:  * Copyright (c) 2008-2011 INRIA
359:  *
360:  * This program is free software: you can redistribute it and/or modify
361:  * it under the terms of the GNU General Public License as published by
362:  * the Free Software Foundation, either version 3 of the License, or
363:  * (at your option) any later version.
364:  *
365:  * This program is distributed in the hope that it will be useful,
366:  * but WITHOUT ANY WARRANTY; without even the implied warranty of
367:  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
368:  * GNU General Public License for more details.
369:  *
370:  * You should have received a copy of the GNU General Public License
371:  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
372:  */
373: 
374: /*
375:  * Proland is distributed under a dual-license scheme.
376:  * You can obtain a specific license from Inria: proland-licensing@inria.fr.
377:  */
378: 
379: /*
380:  * Authors: Eric Bruneton, Antoine Begault, Guillaume Piolat.
381:  */
382: 
383: const float CLOUD_HEIGHT = 5000.0;
384: 
385: float cloudsShadow(vec3 P, vec3 WSD, float h, float vSun, float radius);
386: 
387: 
388: in float h;
389: in vec3 p;
390: in vec3 q;
391: in vec3 n;
392: in vec2 uv;
393: layout(location=0) out vec4 data;
394: 
395: void main() {
396:     vec3 WCP = getWorldCameraPos();
397:     vec3 WSD = getWorldSunDir();
398: 
399:     float pixelScale = length(dFdx(p)+dFdy(p));
400: 
401:     vec3 V = normalize(p);
402:     vec3 P = V * max(length(p), deformation.radius + 10.0);
403:     vec3 v = normalize(P - WCP);
404: 
405:     float nz = 1.0;
406: 
407: #ifdef VERTEX_NORMALS
408:     vec3 fn = normalize(n);
409: #else
410:     vec3 fn = vec3(textureTile(fragmentNormalSampler, uv).xy * 2.0 - 1.0, 0.0);
411:     fn.z = sqrt(max(0.0, 1.0 - dot(fn.xy, fn.xy)));
412:     nz = fn.z;
413:     fn = deformation.tangentFrameToWorld * fn;
414: #endif
415: 
416: #ifndef OTHER_PLANET
417:     if (h &lt; 5.0) {
418:         fn = V; // hack to fix normals in oceans
419:     }
420: #endif
421: 
422:     float cTheta = dot(fn, WSD);
423:     float vSun = dot(V, WSD);
424: 
425:     vec4 reflectance = textureTile(orthoSampler, uv);
426:     reflectance.rgb = tan(1.37 * reflectance.rgb) / tan(1.37); //RGB to reflectance
427: 
428: #ifndef OTHER_PLANET
429:     float rocks = h &lt; 10.0 ? 0.0 : smoothstep(-0.8, -0.6, -nz);
430:     if (rocks &gt; 0.0) {
431:         float rockColor = 0.1 - 0.1 * exp(-6.0 * dot(reflectance.rgb, vec3(0.333)));
432:         reflectance.rgb = rocks * vec3(rockColor) + (1.0 - rocks) * reflectance.rgb;
433:     }
434: #endif
435: 
436:     float waterMask = smoothstep(0.3, 0.9, 2.0 * reflectance.w - 1.0);
437:     float nightMask = smoothstep(0.3, 0.9, 1.0 - 2.0 * reflectance.w);
438: 
439: #ifndef OTHER_PLANET
440:     /*if (h &lt; 5.0 && waterMask &gt; 0.0) {
441:         reflectance.rgb = vec3(0.0);
442:         waterMask = 1.0;
443:     }*/
444: #endif
445: 
446:     vec3 sunL;
447:     vec3 skyE;
448: 
449: #ifdef TERRAIN_SHADOW
450:     vec3 occ = textureTile(ambientApertureSampler, uv).rgb;
451:     float ambient = sqrt(sqrt(occ.x));
452:     vec2 bentn = tan(occ.yz * 2.9 - 1.45) / 8.0;
453:     vec4 ambientAperture = vec4(ambient, deformation.tangentFrameToWorld * vec3(bentn, sqrt(1.0 - dot(bentn, bentn))));
454:     sunRadianceAndSkyIrradiance(P, fn, WSD, pixelScale, ambientAperture, sunL, skyE);
455: #else
456:     sunRadianceAndSkyIrradiance(P, fn, WSD, sunL, skyE);
457: #endif
458: 
459:     sunL *= cloudsShadow(P, WSD, h, vSun, deformation.radius);
460: 
461:     // diffuse ground color
462:     vec3 groundColor = reflectance.rgb * (sunL * max(cTheta, 0.0) + skyE) / 3.14159265;
463: 
464:     vec4 lcc = textureTile(lccSampler, uv);
465:     if (lcc.r &gt; 0.0) { // TODO need also if lcc.r=0?
466:     	float d = length(vec3(q.xy, q.z - deformation.camera.w));
467:         groundColor = treeBrdf(q, d, lcc, v, fn, WSD, V, reflectance.rgb, sunL, skyE);
468:     }
469: 
470: #ifndef OTHER_PLANET
471:     // water specular color due to sunLight
472:     if (waterMask &gt; 0.0) {
473:         groundColor += waterMask * oceanRadiance(-v, V, WSD, getSeaRoughness(), sunL, skyE);
474:     }
475: 
476:     // emitted light (at night)
477:     groundColor += nightMask * smoothstep(0.05, 0.1, -vSun) * vec3(0.0466, 0.0453, 0.0177);
478: #endif
479: 
480:     vec3 extinction;
481:     vec3 inscatter = inScattering(WCP, P, WSD, extinction, 0.0);
482: 
483:     vec3 finalColor = groundColor * extinction + inscatter;
484: 
485:     data.rgb = hdr(finalColor);
486:     data.a = 1.0;
487: 
488:     vec4 PEN = getPencil();
489:     if (PEN.w &gt; 0.0) {
490:         vec3 dp = (normalize(p) - normalize(PEN.xyz)) * deformation.radius;
491:         if (length(dp) &lt; PEN.w) {
492:             data += getPencilColor();
493:         }
494:     }
495: 
496: #ifdef QUADTREE_ON
497:     data.rgb += mod(dot(floor(deformation.offset.xy / deformation.offset.z + 0.5), vec2(1.0)), 2.0) * vec3(0.25, 0.0, 0.0);
498: #endif
499: }
500: 
501: #endif
502: 
0:125(1): error: #extension directive is not allowed in the middle of a shader
</pre></td></tr>
<tr><td class="DATE">10:55:48</td>
<td class="ERROR">[RENDER] OpenGL error 1281, returned string <b>invalid value</b></td></tr>
